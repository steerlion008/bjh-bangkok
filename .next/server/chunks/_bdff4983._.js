module.exports=[628153,e=>e.a(async(t,r)=>{try{var s=e.i(89171),a=e.i(843793),o=t([a]);[a]=o.then?(await o)():o;let i=new Map;async function n(e){try{let{searchParams:t}=new URL(e.url),r=t.get("month"),o=t.get("year"),n=t.get("contact_person"),l=`surgery-schedule-db-${r||"all"}-${o||"all"}-${n||"all"}`,u=i.get(l),c=Date.now();if(u&&c<u.expiresAt)return console.log(`âœ… Returning cached surgery schedule from database`),s.NextResponse.json(u.data,{status:200,headers:{"Cache-Control":"public, s-maxage=30, stale-while-revalidate=60","X-Cache-Status":"HIT","X-Data-Source":"PostgreSQL Database (Cached)"}});console.log(`ðŸ“¡ Fetching surgery schedule from database...`);let d=`
      SELECT 
        id,
        contact_staff as contact_person,
        contact_staff AS à¸œà¸¹à¹‰à¸•à¸´à¸”à¸•à¹ˆà¸­,
        TO_CHAR(
          CASE 
            WHEN booked_surgery_date::text ~ '^[0-9]{1,2}/[0-9]{1,2}/[0-9]{4}$' 
            THEN TO_DATE(booked_surgery_date::text, 'DD/MM/YYYY')
            WHEN booked_surgery_date::text ~ '^[0-9]+$' AND booked_surgery_date::text::INTEGER BETWEEN 1 AND 100000
            THEN DATE '1899-12-30' + booked_surgery_date::text::INTEGER
            ELSE NULL 
          END, 
          'YYYY-MM-DD'
        ) as date_surgery_scheduled,
        booked_surgery_date as à¸§à¸±à¸™à¸—à¸µà¹ˆà¹„à¸”à¹‰à¸™à¸±à¸”à¸œà¹ˆà¸²à¸•à¸±à¸”,
        doctor as doctor,
        doctor as à¸«à¸¡à¸­,
        customer_name as customer_name,
        customer_name as à¸Šà¸·à¹ˆà¸­,
        phone as phone,
        phone as à¹€à¸šà¸­à¸£à¹Œà¹‚à¸—à¸£,
        CASE 
          WHEN REPLACE(proposed_amount, ',', '') ~ '^[0-9]+.?[0-9]*$' 
          THEN REPLACE(proposed_amount, ',', '')::NUMERIC
          ELSE NULL 
        END as proposed_amount,
        COALESCE(proposed_amount, '') as à¸¢à¸­à¸”à¸™à¸³à¹€à¸ªà¸™à¸­,
        appointment_time as à¹€à¸§à¸¥à¸²à¸—à¸µà¹ˆà¸™à¸±à¸”,
        'bjh_all_leads' as data_source
      FROM postgres."BJH-Server".bjh_all_leads
      WHERE booked_surgery_date IS NOT NULL
    `,p=[],h=1;n&&"all"!==n&&(d+=` AND contact_staff = $${h++}`,p.push(n)),d+=` ORDER BY 
      CASE 
        WHEN booked_surgery_date::text ~ '^[0-9]{1,2}/[0-9]{1,2}/[0-9]{4}$' THEN TO_DATE(booked_surgery_date::text, 'DD/MM/YYYY')
        WHEN booked_surgery_date::text ~ '^[0-9]+$' THEN DATE '1899-12-30' + booked_surgery_date::text::INTEGER
        ELSE NULL 
      END DESC NULLS LAST`;let E=await a.default.connect();try{let e=await E.query(d,p);console.log(`âœ… Successfully fetched ${e.rows.length} records from database`);let t={success:!0,data:e.rows,total:e.rows.length,timestamp:new Date().toISOString(),source:"PostgreSQL Database",debug:{filters:{month:r||"all",year:o||"all",contact_person:n||"all"}}};for(let[e,r]of(i.set(l,{data:t,timestamp:c,expiresAt:c+3e4}),i.entries()))c>r.expiresAt+6e4&&i.delete(e);return s.NextResponse.json(t,{status:200,headers:{"Cache-Control":"public, s-maxage=30, stale-while-revalidate=60","X-Cache-Status":"MISS","X-Data-Source":"PostgreSQL Database (Fresh)"}})}finally{E.release()}}catch(t){console.error("Error fetching surgery schedule from database:",t);let e=i.get("surgery-schedule-db");if(e)return console.log("âš ï¸ Using expired cache due to database error"),s.NextResponse.json(e.data,{status:200,headers:{"X-Cache-Status":"STALE","X-Data-Source":"Database (Error Fallback)"}});return s.NextResponse.json({success:!1,error:t.message||"Failed to fetch data from database",details:{type:t.name,message:t.message,hint:"à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸² database à¸¡à¸µà¸•à¸²à¸£à¸²à¸‡ surgery_schedule à¹à¸¥à¸° connection à¸—à¸³à¸‡à¸²à¸™à¸›à¸à¸•à¸´"},data:[]},{status:500})}}async function l(e){try{let{doctor:t,contact_person:r,customer_name:o,phone:n,date_surgery_scheduled:l,appointment_time:u,surgery_date:c,date_consult_scheduled:d,proposed_amount:p,status:h,notes:E}=await e.json();if(!r)return s.NextResponse.json({success:!1,error:"contact_person is required"},{status:400});let g=await a.default.connect();try{let e=`
        INSERT INTO postgres."BJH-Server".bjh_all_leads (
          doctor, contact_staff, customer_name, phone,
          booked_surgery_date, appointment_time, surgery_date,
          booked_consult_date, proposed_amount, status, note
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
        RETURNING *
      `,a=await g.query(e,[t||null,r,o||null,n||null,l||null,u||null,c||null,d||null,p||null,h||null,E||null]);return i.clear(),s.NextResponse.json({success:!0,data:a.rows[0],message:"Surgery schedule created successfully"},{status:201})}finally{g.release()}}catch(e){return console.error("Error creating surgery schedule:",e),s.NextResponse.json({success:!1,error:e.message||"Failed to create surgery schedule"},{status:500})}}async function u(e){try{let{id:t,...r}=await e.json();if(!t)return s.NextResponse.json({success:!1,error:"id is required"},{status:400});let o=Object.keys(r);if(0===o.length)return s.NextResponse.json({success:!1,error:"No fields to update"},{status:400});let n=o.map((e,t)=>`${e} = $${t+2}`).join(", "),l=[t,...o.map(e=>r[e])],u=await a.default.connect();try{let e=`
        UPDATE postgres."BJH-Server".bjh_all_leads
        SET ${n}
        WHERE id = $1
        RETURNING *
      `,t=await u.query(e,l);if(0===t.rows.length)return s.NextResponse.json({success:!1,error:"Surgery schedule not found"},{status:404});return i.clear(),s.NextResponse.json({success:!0,data:t.rows[0],message:"Surgery schedule updated successfully"})}finally{u.release()}}catch(e){return console.error("Error updating surgery schedule:",e),s.NextResponse.json({success:!1,error:e.message||"Failed to update surgery schedule"},{status:500})}}async function c(e){try{let{searchParams:t}=new URL(e.url),r=t.get("id");if(!r)return s.NextResponse.json({success:!1,error:"id is required"},{status:400});let o=await a.default.connect();try{let e=await o.query('DELETE FROM postgres."BJH-Server".bjh_all_leads WHERE id = $1 RETURNING id',[r]);if(0===e.rows.length)return s.NextResponse.json({success:!1,error:"Surgery schedule not found"},{status:404});return i.clear(),s.NextResponse.json({success:!0,message:"Surgery schedule deleted successfully"})}finally{o.release()}}catch(e){return console.error("Error deleting surgery schedule:",e),s.NextResponse.json({success:!1,error:e.message||"Failed to delete surgery schedule"},{status:500})}}async function d(e){return new s.NextResponse(null,{status:200,headers:{"Access-Control-Allow-Origin":"*","Access-Control-Allow-Methods":"GET, POST, PUT, DELETE, OPTIONS","Access-Control-Allow-Headers":"Content-Type"}})}e.s(["DELETE",()=>c,"GET",()=>n,"OPTIONS",()=>d,"POST",()=>l,"PUT",()=>u]),r()}catch(e){r(e)}},!1),599932,e=>e.a(async(t,r)=>{try{var s=e.i(747909),a=e.i(174017),o=e.i(996250),n=e.i(759756),l=e.i(561916),u=e.i(114444),c=e.i(837092),d=e.i(869741),i=e.i(316795),p=e.i(487718),h=e.i(995169),E=e.i(47587),g=e.i(666012),R=e.i(570101),y=e.i(626937),f=e.i(10372),_=e.i(193695);e.i(52474);var N=e.i(600220),m=e.i(628153),w=t([m]);[m]=w.then?(await w)():w;let x=new s.AppRouteRouteModule({definition:{kind:a.RouteKind.APP_ROUTE,page:"/api/surgery-schedule-db/route",pathname:"/api/surgery-schedule-db",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/src/app/api/surgery-schedule-db/route.ts",nextConfigOutput:"",userland:m}),{workAsyncStorage:b,workUnitAsyncStorage:C,serverHooks:A}=x;function S(){return(0,o.patchFetch)({workAsyncStorage:b,workUnitAsyncStorage:C})}async function T(e,t,r){x.isDev&&(0,n.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let s="/api/surgery-schedule-db/route";s=s.replace(/\/index$/,"")||"/";let o=await x.prepare(e,t,{srcPage:s,multiZoneDraftMode:!1});if(!o)return t.statusCode=400,t.end("Bad Request"),null==r.waitUntil||r.waitUntil.call(r,Promise.resolve()),null;let{buildId:m,params:w,nextConfig:S,parsedUrl:T,isDraftMode:b,prerenderManifest:C,routerServerContext:A,isOnDemandRevalidate:v,revalidateOnlyGenerated:D,resolvedPathname:O,clientReferenceManifest:H,serverActionsManifest:$}=o,P=(0,d.normalizeAppPath)(s),L=!!(C.dynamicRoutes[P]||C.routes[O]),j=async()=>((null==A?void 0:A.render404)?await A.render404(e,t,T,!1):t.end("This page could not be found"),null);if(L&&!b){let e=!!C.routes[O],t=C.dynamicRoutes[P];if(t&&!1===t.fallback&&!e){if(S.experimental.adapterPath)return await j();throw new _.NoFallbackError}}let U=null;!L||x.isDev||b||(U=O,U="/index"===U?"/":U);let I=!0===x.isDev||!L,k=L&&!I;$&&H&&(0,u.setReferenceManifestsSingleton)({page:s,clientReferenceManifest:H,serverActionsManifest:$,serverModuleMap:(0,c.createServerModuleMap)({serverActionsManifest:$})});let M=e.method||"GET",q=(0,l.getTracer)(),F=q.getActiveScopeSpan(),Y={params:w,prerenderManifest:C,renderOpts:{experimental:{authInterrupts:!!S.experimental.authInterrupts},cacheComponents:!!S.cacheComponents,supportsDynamicResponse:I,incrementalCache:(0,n.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:S.cacheLife,waitUntil:r.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,r,s)=>x.onRequestError(e,t,s,A)},sharedContext:{buildId:m}},B=new i.NodeNextRequest(e),G=new i.NodeNextResponse(t),W=p.NextRequestAdapter.fromNodeNextRequest(B,(0,p.signalFromNodeResponse)(t));try{let o=async e=>x.handle(W,Y).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let r=q.getRootSpanAttributes();if(!r)return;if(r.get("next.span_type")!==h.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${r.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let a=r.get("next.route");if(a){let t=`${M} ${a}`;e.setAttributes({"next.route":a,"http.route":a,"next.span_name":t}),e.updateName(t)}else e.updateName(`${M} ${s}`)}),u=!!(0,n.getRequestMeta)(e,"minimalMode"),c=async n=>{var l,c;let d=async({previousCacheEntry:a})=>{try{if(!u&&v&&D&&!a)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let s=await o(n);e.fetchMetrics=Y.renderOpts.fetchMetrics;let l=Y.renderOpts.pendingWaitUntil;l&&r.waitUntil&&(r.waitUntil(l),l=void 0);let c=Y.renderOpts.collectedTags;if(!L)return await (0,g.sendResponse)(B,G,s,Y.renderOpts.pendingWaitUntil),null;{let e=await s.blob(),t=(0,R.toNodeOutgoingHttpHeaders)(s.headers);c&&(t[f.NEXT_CACHE_TAGS_HEADER]=c),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let r=void 0!==Y.renderOpts.collectedRevalidate&&!(Y.renderOpts.collectedRevalidate>=f.INFINITE_CACHE)&&Y.renderOpts.collectedRevalidate,a=void 0===Y.renderOpts.collectedExpire||Y.renderOpts.collectedExpire>=f.INFINITE_CACHE?void 0:Y.renderOpts.collectedExpire;return{value:{kind:N.CachedRouteKind.APP_ROUTE,status:s.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:r,expire:a}}}}catch(t){throw(null==a?void 0:a.isStale)&&await x.onRequestError(e,t,{routerKind:"App Router",routePath:s,routeType:"route",revalidateReason:(0,E.getRevalidateReason)({isStaticGeneration:k,isOnDemandRevalidate:v})},A),t}},i=await x.handleResponse({req:e,nextConfig:S,cacheKey:U,routeKind:a.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:C,isRoutePPREnabled:!1,isOnDemandRevalidate:v,revalidateOnlyGenerated:D,responseGenerator:d,waitUntil:r.waitUntil,isMinimalMode:u});if(!L)return null;if((null==i||null==(l=i.value)?void 0:l.kind)!==N.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==i||null==(c=i.value)?void 0:c.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});u||t.setHeader("x-nextjs-cache",v?"REVALIDATED":i.isMiss?"MISS":i.isStale?"STALE":"HIT"),b&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let p=(0,R.fromNodeOutgoingHttpHeaders)(i.value.headers);return u&&L||p.delete(f.NEXT_CACHE_TAGS_HEADER),!i.cacheControl||t.getHeader("Cache-Control")||p.get("Cache-Control")||p.set("Cache-Control",(0,y.getCacheControlHeader)(i.cacheControl)),await (0,g.sendResponse)(B,G,new Response(i.value.body,{headers:p,status:i.value.status||200})),null};F?await c(F):await q.withPropagatedContext(e.headers,()=>q.trace(h.BaseServerSpan.handleRequest,{spanName:`${M} ${s}`,kind:l.SpanKind.SERVER,attributes:{"http.method":M,"http.target":e.url}},c))}catch(t){if(t instanceof _.NoFallbackError||await x.onRequestError(e,t,{routerKind:"App Router",routePath:P,routeType:"route",revalidateReason:(0,E.getRevalidateReason)({isStaticGeneration:k,isOnDemandRevalidate:v})}),L)throw t;return await (0,g.sendResponse)(B,G,new Response(null,{status:500})),null}}e.s(["handler",()=>T,"patchFetch",()=>S,"routeModule",()=>x,"serverHooks",()=>A,"workAsyncStorage",()=>b,"workUnitAsyncStorage",()=>C]),r()}catch(e){r(e)}},!1)];

//# sourceMappingURL=_bdff4983._.js.map